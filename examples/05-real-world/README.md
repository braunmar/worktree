# Example 5: Real-World Production Setup

See how worktree-manager is used in a real production project. This example shows everything working together: multiple repositories, scheduled agents, lifecycle hooks, complex presets, and more.

## Use Case

This is a reference example showing:
- Multi-repo structure (backend, frontend, web, infrastructure, ai-config)
- Scheduled agents for automated housekeeping
- Lifecycle hooks (pre/post start/stop/restart commands)
- Complex presets for different development scenarios
- Generated files and symlinks
- Complete production-grade configuration

## What You'll Learn

- How a real production project uses worktree-manager
- Advanced features (scheduled agents, lifecycle hooks)
- How to structure configuration for 5+ projects
- Best practices and patterns that emerge in production use

## Configuration

See [.worktree.yml](.worktree.yml) (symlinked to [../.worktree.example-real.yml](../.worktree.example-real.yml)) for the complete configuration.

**Size**: 652 lines (compared to 100 lines for Example 3)

**What's included**:
- 5 projects (backend, frontend, web, infrastructure, ai-config)
- 6 presets (fullstack, backend, frontend, all, infra, web)
- 12 environment variables (APP_PORT, FE_PORT, POSTGRES_PORT, REDIS_PORT, MAILPIT_PORT, etc.)
- Scheduled agents (npm-audit, go-deps-update, go-version-upgrade, dead-code-cleanup)
- Lifecycle hooks (start_pre, start_post, stop_pre, stop_post, restart_pre, restart_post)
- Symlinks (.claude directory)
- Generated files (.env.worktree files)

## Project Structure

See [project-structure.txt](project-structure.txt) for the complete directory layout.

**Key characteristics**:
- Each project is a separate Git repository
- Shared `.claude/` directory with skills and hooks (symlinked to all worktrees)
- Multiple preset combinations for different workflows
- Worktrees organized by feature name

---

## Highlights

### 1. Multiple Presets for Different Workflows

```yaml
presets:
  fullstack:
    projects: [backend, frontend]
    description: "Full application (backend + frontend)"

  backend:
    projects: [backend]
    description: "Backend only"

  frontend:
    projects: [frontend]
    description: "Frontend only"

  all:
    projects: [backend, frontend, web, infrastructure, ai-config]
    description: "Everything (for major releases)"

  infra:
    projects: [infrastructure]
    description: "Infrastructure only"

  web:
    projects: [web]
    description: "Marketing website only"
```

**Usage**:
- `worktree new-feature feature/user-auth` → fullstack (default)
- `worktree new-feature feature/landing-redesign --preset web` → web only
- `worktree new-feature release/v2.0 --preset all` → everything

### 2. Scheduled Agents

```yaml
scheduled_agents:
  npm-audit:
    name: "NPM Security Audit & Fix"
    description: "Check and fix npm vulnerabilities in frontend"
    schedule: "0 9 * * MON"  # Mondays at 9 AM
    steps:
      - name: "Run npm audit fix"
        type: shell
        command: "npm audit fix --audit-level=moderate"
        working_dir: "frontend"
```

**What this does**:
- Runs automatically on a schedule (cron expression)
- Creates a worktree instance
- Runs commands (npm audit fix, go get -u, etc.)
- Can create commits and PRs automatically
- Handles failures gracefully

**See**: [.worktree.example-real.yml](../../.worktree.example-real.yml) for the complete agent configuration.

### 3. Lifecycle Hooks

```yaml
projects:
  backend:
    executor: docker
    start_pre_command: "make check-deps"
    start_command: "docker compose up -d"
    start_post_command: "docker compose exec -T api make migrate && make seed"
    stop_pre_command: "make drain-connections"
    stop_post_command: "make cleanup-temp-files"
    restart_pre_command: "make backup-state"
    restart_post_command: "make verify-health"
```

**Hooks triggered**:
- `worktree start` → start_pre → start → start_post
- `worktree stop` → stop_pre → stop → stop_post
- `worktree restart` → restart_pre → (stop cycle) → (start cycle) → restart_post

**Use cases**:
- Verify dependencies before starting
- Run migrations after containers are up
- Gracefully drain connections before stopping
- Clean up temporary files after stopping
- Backup state before restarting
- Verify health after restarting

### 4. Generated Files

```yaml
generated_files:
  - path: "{project}/.env.worktree"
    content: |
      # Generated by worktree-manager for {project}
      # Instance: {instance} | Feature: {feature}
      # DO NOT EDIT - This file is regenerated on worktree start

      APP_PORT={APP_PORT}
      FE_PORT={FE_PORT}
      POSTGRES_PORT={POSTGRES_PORT}
      REDIS_PORT={REDIS_PORT}
      MAILPIT_PORT={MAILPIT_PORT}
      REACT_APP_API_BASE_URL={REACT_APP_API_BASE_URL}

  - path: "{project}/.instance-info"
    content: |
      FEATURE={feature}
      INSTANCE={instance}
      CREATED_AT={timestamp}
```

**What this does**:
- Creates files in each project directory
- Supports placeholders: `{project}`, `{feature}`, `{instance}`, `{timestamp}`, `{env_var_name}`
- Regenerated on every `worktree start`
- Useful for .env files, config files, etc.

---

## Best Practices Demonstrated

### 1. Project Organization

- **Separate Git repositories**: Each project (backend, frontend, web, infrastructure, ai-config) has its own `.git` directory
- **Shared configuration**: `.claude/` directory symlinked to all worktrees for shared skills and hooks
- **Clear naming**: Projects named by function (backend, frontend) not by technology (node-api, react-app)

### 2. Port Allocation Strategy

- **Wide ranges**: `[8080, 8180]` supports 100 instances (more than enough)
- **Consistent gaps**: FE_PORT starts at 3000, APP_PORT at 8080 (easy to remember)
- **Display-only ports**: MAILPIT_SMTP_PORT calculated as `{MAILPIT_PORT} + 1000` (not allocated separately)

### 3. Preset Design

- **Default preset**: `fullstack` (most common use case)
- **Specialized presets**: `backend` (API only), `frontend` (UI only), `web` (marketing), `infra` (infrastructure)
- **Comprehensive preset**: `all` (for major releases, testing everything)

### 4. Docker Executor Usage

- **All projects use Docker**: Consistent development environment across team
- **Post-start commands**: Migrations, seed data, health checks
- **Health checks**: Verify services are ready before declaring success

### 5. Environment Variables

- **Port variables**: All services get unique ports
- **String templates**: Frontend knows backend URL via `REACT_APP_API_BASE_URL`
- **Database connections**: Use `{POSTGRES_PORT}` in connection strings (for external tools), but fixed port inside Docker network

---

## Key Differences from Simpler Examples

| Feature | Example 3 | Example 5 (Real-World) |
|---------|-----------|------------------------|
| Projects | 2 (backend, frontend) | 5 (backend, frontend, web, infrastructure, ai-config) |
| Presets | 3 (fullstack, backend, frontend) | 6 (fullstack, backend, frontend, all, infra, web) |
| Env vars | 5 | 12+ |
| Lifecycle hooks | Minimal | Extensive (pre/post for all operations) |
| Scheduled agents | None | 4 (npm-audit, go-deps-update, go-version-upgrade, dead-code-cleanup) |
| Generated files | 1 (.env.worktree) | 2+ (.env.worktree, .instance-info, etc.) |
| Complexity | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

---

## How to Use

### 1. Study the Configuration

```bash
# Open the complete configuration
cat examples/05-real-world/.worktree.yml

# Or view the full file
cat .worktree.example-real.yml
```

### 2. Identify Patterns for Your Project

Look for patterns that apply to your project:
- Do you have multiple repos? (See projects section)
- Do you need different combinations? (See presets section)
- Do you want automated maintenance? (See scheduled_agents section)
- Do you need setup/teardown steps? (See lifecycle hooks)

### 3. Adapt to Your Needs

Copy sections that are relevant:
- Start with Example 3 (simpler)
- Add features from Example 5 as needed
- Don't over-engineer - only add what you actually need

### 4. Test Incrementally

Don't try to adopt everything at once:
1. Start with basic multi-repo setup (projects + presets)
2. Add environment variables and Docker integration
3. Add lifecycle hooks if needed
4. Add scheduled agents last (once core workflow is stable)

---

## When to Use This Example

**Use this example as a reference when**:
- You have 3+ projects in your mono-repo or multi-repo setup
- You need different preset combinations for different workflows
- You want automated housekeeping (scheduled agents)
- You need lifecycle hooks for setup/teardown
- You're ready for production-grade configuration

**Don't start with this example if**:
- You're new to worktree-manager (start with Example 1 or 3)
- You only have 1-2 projects (use Example 2 or 3)
- You don't need the complexity yet (add features incrementally)

---

## Related Resources

- **[Example 3: Fullstack Docker](../03-fullstack-docker/)** - Start here before jumping to this example
- **[Example 4: Polyglot Services](../04-polyglot-services/)** - Multiple services with preset combinations
- **[.worktree.example.yml](../../.worktree.example.yml)** - Complete configuration reference with comments

---

## Key Takeaways

✅ **Real-world configs are larger** but built from the same basic patterns
✅ **Presets are powerful** for organizing different development workflows
✅ **Lifecycle hooks** enable custom setup/teardown logic
✅ **Scheduled agents** automate housekeeping tasks
✅ **Generated files** reduce manual configuration
✅ **Symlinks share resources** across all worktrees
✅ **Start simple, add complexity** as needed - don't over-engineer upfront

**This example shows what's possible. Start simple, add features incrementally!**
