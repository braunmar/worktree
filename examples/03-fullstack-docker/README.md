# Example 3: Fullstack Docker (Most Common Use Case)

Learn how to integrate worktree-manager with Docker Compose. This is what most teams need!

## Use Case

You have:
- Frontend and Backend projects
- Both use Docker Compose for local development
- Hardcoded ports in docker-compose.yml (8080, 3000, 5432, etc.)
- Want to run multiple feature branches simultaneously

**The Problem**: You can only run ONE instance at a time because ports conflict.

**The Solution**: Use `${APP_PORT:-8080}` pattern in docker-compose.yml + worktree-manager allocates unique ports per instance.

## What You'll Learn

- How to configure docker-compose.yml with `${ENV_VAR:-default}` pattern
- How worktree-manager injects env vars before `docker compose up`
- How to run unlimited instances without port conflicts
- How to set up multi-repo structure with shared `.claude/` directory
- How symlinks and generated files work

## Project Structure

See [project-structure.txt](project-structure.txt) for detailed layout with explanations.

**Key Points**:
- Backend and frontend are separate git repos
- `.claude/` directory is shared across all worktrees (symlinked)
- Each instance gets its own `worktrees/feature-name/` directory
- `.worktree-instance` marker file enables auto-detection
- Generated `.env.worktree` files contain all env vars

---

## Configuration Walkthrough

Let's break down the [.worktree.yml](.worktree.yml) file section by section.

### Projects Section

```yaml
projects:
  backend:
    executor: docker
    dir: backend
    main_branch: main
    start_command: "docker compose up -d"
    start_post_command: "docker compose exec -T api make migrate"
    claude_working_dir: true

  frontend:
    executor: docker
    dir: frontend
    main_branch: main
    start_command: "docker compose up -d"
```

**Key differences from Example 2**:
- `executor: docker` instead of `process`
- `start_command: "docker compose up -d"` runs Docker Compose in detached mode
- `start_post_command` runs AFTER containers are up (migrations, fixtures, etc.)

**What happens when you run `worktree new-feature`**:
1. Exports env vars (APP_PORT, POSTGRES_PORT, etc.)
2. Changes directory to backend worktree
3. Runs `docker compose up -d` (Docker reads env vars from environment!)
4. Waits for containers to be healthy
5. Runs `docker compose exec -T api make migrate` (optional post-start command)
6. Repeats for frontend

### Environment Variables (The Critical Part!)

```yaml
env_variables:
  APP_PORT:
    name: "Backend API"
    url: "http://{host}:{port}"
    port: "8080"
    env: "APP_PORT"
    range: [8080, 8180]
```

**How this works**:

1. **Allocation**: Worktree-manager finds an available port in range [8080, 8180]
   - Instance 0 gets 8080
   - Instance 1 gets 8081
   - And so on...

2. **Export**: Before running `docker compose up`, worktree-manager exports:
   ```bash
   export APP_PORT=8080
   export POSTGRES_PORT=5432
   export MAILPIT_PORT=8025
   export FE_PORT=3000
   export REACT_APP_API_BASE_URL=http://localhost:8080
   ```

3. **Docker Reads**: Docker Compose reads these env vars when parsing docker-compose.yml

**String Template (Frontend Needs to Know Backend URL)**:

```yaml
  REACT_APP_API_BASE_URL:
    name: "API Base URL (for frontend)"
    url: "{value}"
    value: "http://{host}:{APP_PORT}"
    env: "REACT_APP_API_BASE_URL"
```

**How this works**:
1. First, `APP_PORT` is allocated (e.g., 8080)
2. Then, `REACT_APP_API_BASE_URL` is calculated: `"http://localhost:8080"`
3. Frontend container gets this env var and knows where to call the API!

### Symlinks

```yaml
symlinks:
  - path: .claude
    description: "Shared Claude config (skills, hooks)"
```

**What this does**:
Creates symbolic links in each worktree pointing back to the shared `.claude/` directory.

```
worktrees/feature-user-auth/.claude -> ../../.claude
worktrees/feature-payments/.claude -> ../../.claude
```

**Why this is useful**:
- Share Claude skills across all features
- Share Git hooks
- Share configuration files
- One place to update, all worktrees get it

### Generated Files

```yaml
generated_files:
  - path: "{project}/.env.worktree"
    content: |
      # Generated by worktree-manager for {project}
      APP_PORT={APP_PORT}
      FE_PORT={FE_PORT}
      POSTGRES_PORT={POSTGRES_PORT}
      MAILPIT_PORT={MAILPIT_PORT}
      REACT_APP_API_BASE_URL={REACT_APP_API_BASE_URL}
```

**What this does**:
Creates a `.env.worktree` file in each project directory with all env vars.

**Example output** (`worktrees/feature-user-auth/backend/.env.worktree`):
```bash
# Generated by worktree-manager for backend
# Instance: 0 | Feature: feature-user-auth
# DO NOT EDIT - This file is regenerated on worktree start

APP_PORT=8080
FE_PORT=3000
POSTGRES_PORT=5432
MAILPIT_PORT=8025
REACT_APP_API_BASE_URL=http://localhost:8080
```

**How to use in docker-compose.yml**:
```yaml
services:
  api:
    env_file:
      - .env.worktree  # Load all env vars from generated file
```

---

## Docker Compose Integration (The Magic!)

This is the KEY to making everything work.

### The Problem: Hardcoded Ports

**Before (won't work for multiple instances)**:

```yaml
# backend/docker-compose.yml
services:
  api:
    ports:
      - "8080:8080"  # ‚ùå HARDCODED

  postgres:
    ports:
      - "5432:5432"  # ‚ùå HARDCODED
```

**If you try to run two instances**:
```bash
worktree new-feature feature/first   # ‚úÖ Works (binds to 8080, 5432)
worktree new-feature feature/second  # ‚ùå ERROR! Ports already in use
```

### The Solution: Environment Variable Substitution

**After (works for unlimited instances)**:

```yaml
# backend/docker-compose.yml
services:
  api:
    ports:
      - "${APP_PORT:-8080}:8080"  # ‚úÖ DYNAMIC
    environment:
      - PORT=8080  # Internal port (always 8080 in container)
      - DATABASE_URL=postgresql://postgres:postgres@postgres:${POSTGRES_PORT}/app

  postgres:
    ports:
      - "${POSTGRES_PORT:-5432}:5432"  # ‚úÖ DYNAMIC
```

**How `${APP_PORT:-8080}` works**:
- `${APP_PORT}` - Read APP_PORT from environment
- `:-8080` - If APP_PORT not set, default to 8080
- Result: If `APP_PORT=8081`, Docker binds host port 8081 to container port 8080

**Port mapping format**: `"HOST:CONTAINER"`
- Left side (HOST): The port on your computer (dynamic, from worktree-manager)
- Right side (CONTAINER): The port inside Docker container (fixed, always the same)

**Examples**:
- `"${APP_PORT:-8080}:8080"` ‚Üí Instance 0: `"8080:8080"`, Instance 1: `"8081:8080"`
- `"${POSTGRES_PORT:-5432}:5432"` ‚Üí Instance 0: `"5432:5432"`, Instance 1: `"5433:5432"`

**Inside containers**: Always use fixed ports (8080, 5432). Containers don't know or care about external ports!

### Complete Backend Example

See [backend/docker-compose.example.yml](backend/docker-compose.example.yml) for the full example with detailed comments.

**Key patterns**:

1. **Web Service** (API):
   ```yaml
   api:
     ports:
       - "${APP_PORT:-8080}:8080"
     environment:
       - PORT=8080  # Always 8080 inside container
   ```

2. **Database**:
   ```yaml
   postgres:
     ports:
       - "${POSTGRES_PORT:-5432}:5432"
     environment:
       - DATABASE_URL=postgresql://user:pass@postgres:${POSTGRES_PORT}/db
   ```

3. **Service-to-Service Communication** (Backend ‚Üí Database):
   ```yaml
   api:
     environment:
       # INSIDE Docker network, use service name and internal port
       - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/app
   ```

   **Note**: `postgres:5432` NOT `postgres:${POSTGRES_PORT}` because inside Docker network, containers talk directly (no port mapping).

4. **Service-to-Service Communication** (Frontend ‚Üí Backend):
   ```yaml
   frontend:
     environment:
       # OUTSIDE Docker network (browser makes the call), use host and external port
       - REACT_APP_API_BASE_URL=http://localhost:${APP_PORT}
   ```

   **Note**: Frontend runs in browser, so it calls `localhost:${APP_PORT}` (external port).

---

## Try It Out

### Prerequisites

1. **Docker and Docker Compose installed**:
   ```bash
   docker --version
   docker compose version
   ```

2. **Two git repositories with at least one commit each**:
   ```bash
   cd backend && git init && git add . && git commit -m "init" && cd ..
   cd frontend && git init && git add . && git commit -m "init" && cd ..
   ```

3. **docker-compose.yml files updated** with `${VAR:-default}` pattern:
   - Copy [backend/docker-compose.example.yml](backend/docker-compose.example.yml)
   - Copy [frontend/docker-compose.example.yml](frontend/docker-compose.example.yml)
   - Adapt to your project structure

### Step 1: Update Your docker-compose.yml Files

**In backend/docker-compose.yml**:
```yaml
services:
  api:
    ports:
      - "${APP_PORT:-8080}:8080"  # Change from "8080:8080"
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@postgres:${POSTGRES_PORT}/app

  postgres:
    ports:
      - "${POSTGRES_PORT:-5432}:5432"  # Change from "5432:5432"
```

**In frontend/docker-compose.yml**:
```yaml
services:
  app:
    ports:
      - "${FE_PORT:-3000}:3000"  # Change from "3000:3000"
    environment:
      - REACT_APP_API_BASE_URL=${REACT_APP_API_BASE_URL}
```

### Step 2: Copy Configuration

```bash
cp examples/03-fullstack-docker/.worktree.yml .
```

### Step 3: Create First Instance

```bash
worktree new-feature feature/user-auth
```

**What happens** (step by step):

1. ‚úÖ Allocates ports:
   - APP_PORT=8080
   - FE_PORT=3000
   - POSTGRES_PORT=5432
   - MAILPIT_PORT=8025

2. ‚úÖ Calculates string templates:
   - REACT_APP_API_BASE_URL=http://localhost:8080

3. ‚úÖ Creates backend git worktree:
   - Directory: `worktrees/feature-user-auth/backend/`
   - Branch: `feature/user-auth`

4. ‚úÖ Creates frontend git worktree:
   - Directory: `worktrees/feature-user-auth/frontend/`
   - Branch: `feature/user-auth`

5. ‚úÖ Creates symlinks:
   - `worktrees/feature-user-auth/.claude -> ../../.claude`

6. ‚úÖ Generates `.env.worktree` files in both projects

7. ‚úÖ Exports env vars and runs `docker compose up -d` in backend:
   ```bash
   export APP_PORT=8080
   export POSTGRES_PORT=5432
   export MAILPIT_PORT=8025
   cd worktrees/feature-user-auth/backend
   docker compose up -d
   ```

8. ‚úÖ Runs post-start command:
   ```bash
   docker compose exec -T api make migrate
   ```

9. ‚úÖ Exports env vars and runs `docker compose up -d` in frontend:
   ```bash
   export FE_PORT=3000
   export REACT_APP_API_BASE_URL=http://localhost:8080
   cd worktrees/feature-user-auth/frontend
   docker compose up -d
   ```

10. ‚úÖ Done! Services are running.

### Step 4: Create Second Instance

```bash
worktree new-feature feature/payments
```

**What happens**:
1. ‚úÖ Allocates DIFFERENT ports (no conflicts!):
   - APP_PORT=8081
   - FE_PORT=3001
   - POSTGRES_PORT=5433
   - MAILPIT_PORT=8026

2. ‚úÖ Creates separate worktrees for feature/payments

3. ‚úÖ Runs `docker compose up -d` with NEW ports

4. ‚úÖ Both instances running simultaneously!

---

## Verification

### Check Running Instances

```bash
worktree list
```

Shows:
```
Feature              Preset      Projects            Status   Ports
feature-user-auth   fullstack   backend, frontend   Running  8080, 3000
feature-payments    fullstack   backend, frontend   Running  8081, 3001
```

### Check Ports for Each Instance

```bash
worktree ports feature-user-auth
```

Shows:
```
‚úì Backend API           http://localhost:8080
‚úì Frontend              http://localhost:3000
‚úì PostgreSQL            localhost:5432
‚úì Mailpit UI            http://localhost:8025
‚úì API Base URL          http://localhost:8080
```

```bash
worktree ports feature-payments
```

Shows:
```
‚úì Backend API           http://localhost:8081
‚úì Frontend              http://localhost:3001
‚úì PostgreSQL            localhost:5433
‚úì Mailpit UI            http://localhost:8026
‚úì API Base URL          http://localhost:8081
```

**Different ports!** ‚ú®

### Check Docker Containers

```bash
# First instance containers
docker compose -p myproject-feature-user-auth-backend ps

# Second instance containers
docker compose -p myproject-feature-payments-backend ps
```

**Note**: Each instance uses a different compose project name to keep containers isolated.

### Test the Services

```bash
# Test first backend
curl http://localhost:8080/api/health

# Test second backend
curl http://localhost:8081/api/health

# Open first frontend
open http://localhost:3000

# Open second frontend
open http://localhost:3001
```

**Both work simultaneously!** üéâ

Open both frontends in different browser tabs. You can:
- Work on feature/user-auth in one tab (port 3000 ‚Üí API 8080)
- Work on feature/payments in another tab (port 3001 ‚Üí API 8081)
- Test interactions between features
- No conflicts!

---

## Common Workflows

### Workflow 1: Full-Stack Feature Development

```bash
worktree new-feature feature/user-profile
# Runs: Backend (8080) + Frontend (3000) + Database (5432) + Mailpit (8025)
```

**Use when**: Building features that need both UI and API.

### Workflow 2: Backend-Only Development

```bash
worktree new-feature feature/new-endpoint --preset backend
# Runs: Backend (8081) + Database (5433) + Mailpit (8026) only
```

**Use when**:
- Testing API endpoints with curl/Postman
- Writing integration tests
- Backend-only work

**Saves resources**: No frontend containers running.

### Workflow 3: Quick Context Switch

```bash
# You're working on feature/user-auth (ports 8080, 3000)
# Urgent bug in production needs investigation

worktree new-feature hotfix/urgent-bug --preset backend
# Creates NEW instance (ports 8081, 5433)
# You can test the fix WITHOUT stopping your feature work!
```

### Workflow 4: Auto-Detection

```bash
# From any directory within a worktree, commands auto-detect the instance:
cd worktrees/feature-user-auth/backend
worktree ports          # Auto-detects: feature-user-auth
worktree status         # Auto-detects: feature-user-auth
worktree stop           # Auto-detects: feature-user-auth
```

**No need to type the feature name!** The `.worktree-instance` marker file enables this.

---

## Troubleshooting

### Problem: Port conflict "address already in use"

**Symptom**:
```
Error starting userland proxy: listen tcp4 0.0.0.0:8080: bind: address already in use
```

**Cause**: Another Docker container (or process) is using port 8080.

**Solution 1**: Check what's using the port:
```bash
lsof -i :8080
# Or
worktree list  # Check other worktree instances
```

**Solution 2**: Run health check:
```bash
worktree doctor
```

Shows port conflicts and suggests fixes.

**Solution 3**: Stop conflicting instance:
```bash
worktree stop feature-old-instance
# Or
docker compose down  # From the conflicting project directory
```

### Problem: Frontend can't reach backend

**Symptom**: Console errors like "Failed to fetch http://localhost:undefined/api/users"

**Cause**: Frontend isn't reading REACT_APP_API_BASE_URL env var.

**Solution**: Check your frontend code:

```javascript
// ‚ùå Wrong
const API_URL = 'http://localhost:8080';  // Hardcoded

// ‚úÖ Correct
const API_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8080';
```

**Verify env var is set**:
```bash
cd worktrees/feature-test/frontend
cat .env.worktree
# Should contain: REACT_APP_API_BASE_URL=http://localhost:8080
```

**For Vite projects**: Use `import.meta.env.VITE_API_BASE_URL` instead of `process.env.REACT_APP_API_BASE_URL`.

### Problem: Backend can't connect to database

**Symptom**: Application errors like "connection refused" or "could not connect to server"

**Cause**: DATABASE_URL isn't using the correct port.

**Solution**: Check your docker-compose.yml:

```yaml
# ‚úÖ Correct - Inside Docker network, use internal port
services:
  api:
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/app

# ‚ùå Wrong - Don't use ${POSTGRES_PORT} for inter-container communication
services:
  api:
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@postgres:${POSTGRES_PORT}/app
```

**Why**: Inside Docker network, containers communicate directly using service names and internal ports.

### Problem: `docker compose up` works manually but fails with worktree-manager

**Cause**: Env vars aren't being exported correctly.

**Debug**:
```bash
cd worktrees/feature-test/backend
cat .env.worktree  # Check env vars are correct
```

**Test manually**:
```bash
cd worktrees/feature-test/backend
export APP_PORT=8080
export POSTGRES_PORT=5432
docker compose up -d
```

If it works manually, there might be an issue with worktree-manager. Check logs or report an issue.

### Problem: Migrations fail in start_post_command

**Symptom**: `docker compose exec` returns "No such container"

**Cause**: Container not fully started yet.

**Solution**: Add health check to your docker-compose.yml:

```yaml
services:
  api:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s

  postgres:
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
```

Or add a wait before migrations:
```yaml
projects:
  backend:
    start_post_command: "sleep 5 && docker compose exec -T api make migrate"
```

---

## What's Next?

You now know how to integrate worktree-manager with Docker Compose! Here's what to explore next:

### For Multiple Services

**[Example 4: Polyglot Services](../04-polyglot-services/)** - Learn how to run Node API + Python Worker + Frontend with different preset combinations.

### For Deep Dive

**[Docker Port Patterns](../../docs/PORT-PATTERNS.md)** - Comprehensive guide to Docker Compose integration patterns, common issues, and advanced configurations.

### For Migration

**[Migration Guide](../MIGRATION-GUIDE.md)** - Step-by-step guide for migrating existing projects from hardcoded ports to dynamic allocation.

### For Production Reference

**[Example 5: Real-World](../05-real-world/)** - See how a real production project uses worktree-manager with 5+ repositories, scheduled agents, and lifecycle hooks.

---

## Key Takeaways

‚úÖ **Use `${VAR:-default}` pattern** in docker-compose.yml for all ports
‚úÖ **Port mapping**: `"HOST:CONTAINER"` - left side is dynamic, right side is fixed
‚úÖ **Inside Docker network**: Use service names and internal ports (e.g., `postgres:5432`)
‚úÖ **Outside Docker network** (browser): Use localhost and external ports (e.g., `localhost:${APP_PORT}`)
‚úÖ **Worktree-manager exports env vars** before running `docker compose up`
‚úÖ **Unlimited instances**: Each gets unique ports automatically
‚úÖ **Symlinks share files** (like `.claude/` directory) across all worktrees
‚úÖ **Generated files** (like `.env.worktree`) contain all env vars per instance
‚úÖ **Auto-detection**: No need to type feature name when inside a worktree directory

**This pattern is the foundation for multi-instance Docker development!** üöÄ
